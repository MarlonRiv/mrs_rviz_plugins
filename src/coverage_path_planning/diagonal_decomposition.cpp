#include <coverage_path_planning/diagonal_decomposition.h>

#include <boost/geometry.hpp>

#include <vector>
#include <limits>
#include <cmath>

namespace bg = boost::geometry;

using Polygon = mrs_lib::Polygon;
using Point2d = mrs_lib::Point2d;

namespace mrs_rviz_plugins {

void DiagonalDecomposition::initialize (rviz::Property* property_container, Ogre::SceneManager* scene_manager, Ogre::SceneNode* root_node){

}

void DiagonalDecomposition::compute() {
  std::cout << "compute\n";
  
  // outer
  Polygon poly = mrs_lib::Polygon();
  {mrs_lib::Point2d p{2, 12};
    bg::append(poly, p);}

  {mrs_lib::Point2d p{17, 12};
    bg::append(poly, p);}
  
  {mrs_lib::Point2d p{20, 10};
    bg::append(poly, p);}

  {mrs_lib::Point2d p{20, 0};
    bg::append(poly, p);}

  {mrs_lib::Point2d p{14, 8};
    bg::append(poly, p);}
  
  {mrs_lib::Point2d p{1.75, 0};
    bg::append(poly, p);}
  
  {mrs_lib::Point2d p{0, 10};
    bg::append(poly, p);}

  {mrs_lib::Point2d p{2, 12};
    bg::append(poly, p);}

  // bg::correct(poly);
  std::string msg;
  bg::is_valid(poly, msg);
  std::cout << msg << std::endl;

    getPartition(poly, 0);
  for(int i=0; i<7; i++){
    // std::cout << "got a partition\n";
  }
}

std::pair<mrs_lib::Polygon, DiagonalDecomposition::Line> DiagonalDecomposition::getPartition(Polygon& border, int index_start) {
  // Todo: implement me
  Polygon::ring_type outer = border.outer();

  // the first and last points of ring must be equal, 
  // the following is done for prettier computations
  if(index_start == outer.size()-1){
    index_start = 0; 
  }
  // This is for iterating in counter-clockwise direction
  // std::vector<size_t> indices(outer.size()-1);
  // for(size_t i=0; i<indices.size(); ++i){
  //   int cur = index_start - i;
  //   indices[i] = cur < 0 ? indices.size() + cur : cur;
  // }

  std::vector<size_t> indices(outer.size()-1);
  for(size_t i=0; i<indices.size(); ++i){
    int cur = index_start + i;
    indices[i] = cur % indices.size();
  }
  std::cout << std::endl;

  // |---------------- MP3 algorithm ----------------|

  // Initially, the list consists of one vertex.
  Polygon cur_part;
  bg::append(cur_part, outer[indices[0]]);

  getPartitionClockwise(border, index_start, cur_part);

  getPartitionCounterClockwise(border, index_start, cur_part);

  std::cout << bg::wkt(cur_part) << std::endl;





  Polygon res1;
  Line res2;
  return std::pair<Polygon, Line>(res1, res2);
}

bool DiagonalDecomposition::getPartitionClockwise(const Polygon& border, int index_start, Polygon& res){
  std::cout<<"\n started " << "clockwise"  << std::endl;
  // Todo: implement me
  Polygon::ring_type outer = border.outer();

  // the first and last points of ring must be equal, 
  // the following is done for prettier computations
  if(index_start == outer.size()-1){
    index_start = 0; 
  }

  // Note: the points in Polygon are stored in clockwise order
  std::vector<size_t> indices(outer.size()-1);
  
  for(size_t i=0; i<indices.size(); ++i){
    int cur = index_start + i;
    indices[i] = cur % indices.size();
  }

  // We add the next consecutive vertex (in clockwise order only) of P
  bg::append(res, outer[indices[1]]);
  
  bool is_outer_convex = true;

  // We go on adding new vertices to L until all the vertices of P are in L...
  for(int i=1; i<indices.size()-1; i++){
    // ... or until we first find a vertex failing one of the three conditions.
    // Note: indices[i] is the index of last vertex in res and we consider adding indices[i+1]
    
    // Checking the angles in clockwise order
    if(ang(outer[indices[i-1]], outer[indices[i]], outer[indices[i+1]]) > M_PI ||
      ang(outer[indices[i]], outer[indices[i+1]], res.outer()[0]) > M_PI    ||
      ang(outer[indices[i+1]], res.outer()[0], res.outer()[1]) > M_PI)
    {
      std::cout << "clockwise break\n";
      is_outer_convex = false;
      break;
    }

    bg::append(res, outer[indices[i+1]]);
    std::cout << "appended " << bg::wkt(outer[indices[i+1]]) << std::endl;
  }

  // If the convex polygon generated is the whole polygon P, the algorithm stops
  if(is_outer_convex){
    Line res_line = {outer[index_start], outer[index_start]};
    std::cout << "terminating\n";
    std::cout << bg::wkt(res) << std::endl;
    // res = res;
    return true;
  }

  // If k > 2, then we have to check whether the convex polygon
  // generated by the diagonal v_k v_1 contains vertices of P \ L.
  if(res.outer().size() > 2){
    std::cout<< "size > 2\n";
    Polygon tmp_complete = res;
    bg::append(tmp_complete, res.outer()[0]);
    bg::correct(tmp_complete);

    std::cout << std::endl << std::endl;
    for(int i=res.outer().size(); i<indices.size(); i++){ // iterating over vertices of P \ L.
      // If a vertex v is found to be in the polygon generated by L, then 
      // we remove from L its last vertex v_k and all the vertices of L in 
      // the half-plane generated by [v_1, v] containing v_k .
      if(bg::within(outer[indices[i]], tmp_complete)){
        Point2d v_1 = border.outer()[index_start];
        Point2d v_k = res.outer().back();
        Point2d v = outer[indices[i]];

        std::cout << "v_1: " << bg::wkt(v_1) << std::endl;
        std::cout << "v_k: " << bg::wkt(v_k) << std::endl;
        std::cout << "v: " << bg::wkt(v) << std::endl;

        float a = (bg::get<1>(v) - bg::get<1>(v_1)) / (bg::get<0>(v) - bg::get<0>(v_1));
        float b = -1;
        float c = bg::get<1>(v_1) - (a * bg::get<0>(v_1));

        // Note: we only consider sign of distance, so the denominator is not needed
        // float abs_w = std::sqrt(std::pow(a, 2) + std::pow(b, 2));
        float dist_v_k = (a * bg::get<0>(v_k)) + (b * bg::get<1>(v_k)) + c ; //  / abs_w;

        // Starting from 1 in order not to delete the first vertex because of inaccuracy
        for(int j=1; j<res.outer().size();){
          float cur_dist =  (a * bg::get<0>(res.outer()[j])) + (b * bg::get<1>(res.outer()[j])) + c;
          if((cur_dist > 0 && dist_v_k > 0) || (cur_dist < 0 && dist_v_k < 0)){
            std::cout << "removing " << bg::wkt(res.outer()[j]) << std::endl;
            res.outer().erase(res.outer().begin() + j);
          }else{
            ++j;
          }
        }
      }
    }
  }

  // res = cur_part;
  return false;
}

bool DiagonalDecomposition::getPartitionCounterClockwise(const Polygon& border, int index_start, Polygon& res){
  std::cout<<"\n started " << "counter clockwise"  << std::endl;
  // Todo: implement me
  Polygon::ring_type outer = border.outer();

  // the first and last points of ring must be equal, 
  // the following is done for prettier computations
  if(index_start == outer.size()-1){
    index_start = 0; 
  }

  // Note: the points in Polygon are stored in clockwise order
  std::vector<size_t> indices(outer.size()-1);
  for(size_t i=0; i<indices.size(); ++i){
    int cur = index_start - i;
    indices[i] = cur < 0 ? indices.size() + cur : cur;
  }

  Point2d A = res.outer()[0];
  Point2d B = res.outer()[1];
  Point2d C = res.outer()[res.outer().size() - 2];
  Point2d D = res.outer().back();
  Point2d G = outer[indices[1]];

  // std::cout << "A: " << bg::wkt(A) << std::endl;
  // std::cout << "B: " << bg::wkt(B) << std::endl;
  // std::cout << "C: " << bg::wkt(C) << std::endl;
  // std::cout << "D: " << bg::wkt(D) << std::endl;
  // std::cout << "G: " << bg::wkt(G) << std::endl;

  // We add the next consecutive vertex if it is suitable
  if(ang(G, A, B) < M_PI &&
    ang(D, G, A) < M_PI &&
    ang(C, D, G) < M_PI)
  {
    std::cout << "counter clockwise appended next\n";
    res.outer().insert(res.outer().begin(), outer[indices[1]]);
  }else{
    // If it does not fit, no reason to continue
    return false;
  }


  // We go on adding new vertices to L until all the vertices of P are in L...
  int last_i = 1;
  for(int i=1; i<indices.size()-1; i++, last_i++){
    // ... or until we first find a vertex failing one of the three conditions.
    // Note: indices[i] is the index of last vertex in res and we consider adding indices[i+1]

    // Checking the angles in counter-clockwise order
    if(ang(outer[indices[i+1]], outer[indices[i]], outer[indices[i-1]]) > M_PI ||
      ang(res.outer().back(), outer[indices[i+1]], outer[indices[i]]) > M_PI    ||
      ang(res.outer()[res.outer().size() - 2], res.outer().back(), outer[indices[i+1]]) > M_PI)
    {
      std::cout << "counter clockwise break\n";
      // is_outer_convex = false;
      break;
    }

    res.outer().insert(res.outer().begin(), outer[indices[i+1]]);
    std::cout << "appended " << bg::wkt(outer[indices[i+1]]) << std::endl;
  }

  // If the convex polygon generated is the whole polygon P, the algorithm stops
  // if(is_outer_convex){
  //   Line res_line = {outer[index_start], outer[index_start]};
  //   std::cout << "terminating\n";
  //   std::cout << bg::wkt(res) << std::endl;
  //   // res = res;
  //   return true;
  // }

  // If k > 2, then we have to check whether the convex polygon
  // generated by the diagonal v_k v_1 contains vertices of P \ L.
  if(res.outer().size() > 2){
    std::cout<< "size > 2\n";
    Polygon tmp_complete = res;
    bg::append(tmp_complete, res.outer()[0]);
    bg::correct(tmp_complete);

    std::cout << std::endl << std::endl;
    for(int i=last_i; i<indices.size(); i++){ // iterating over vertices of P \ L.
      // If a vertex v is found to be in the polygon generated by L, then 
      // we remove from L its last vertex v_k and all the vertices of L in 
      // the half-plane generated by [v_1, v] containing v_k .
      if(bg::within(outer[indices[i]], tmp_complete)){
        Point2d v_1 = res.outer().back();
        Point2d v_k = res.outer().front();
        Point2d v = outer[indices[i]];

        std::cout << "v_1: " << bg::wkt(v_1) << std::endl;
        std::cout << "v_k: " << bg::wkt(v_k) << std::endl;
        std::cout << "v: " << bg::wkt(v) << std::endl;

        float a = (bg::get<1>(v) - bg::get<1>(v_1)) / (bg::get<0>(v) - bg::get<0>(v_1));
        float b = -1;
        float c = bg::get<1>(v_1) - (a * bg::get<0>(v_1));

        // Note: we only consider sign of distance, so the denominator is not needed
        // float abs_w = std::sqrt(std::pow(a, 2) + std::pow(b, 2));
        float dist_v_k = (a * bg::get<0>(v_k)) + (b * bg::get<1>(v_k)) + c ; //  / abs_w;

        for(int j=0; j<res.outer().size();){
          float cur_dist =  (a * bg::get<0>(res.outer()[j])) + (b * bg::get<1>(res.outer()[j])) + c;
          if((cur_dist > 0 && dist_v_k > 0) || (cur_dist < 0 && dist_v_k < 0)){
            std::cout << "removing " << bg::wkt(res.outer()[j]) << std::endl;
            res.outer().erase(res.outer().begin() + j);
          }else{
            ++j;
          }
        }
      }
    }
  }

  // res = cur_part;
  return false;
}


// Algorithm 2: Procedure DrawTrueDiagonal
std::pair<mrs_lib::Polygon::ring_type, DiagonalDecomposition::Line> DiagonalDecomposition::drawTrueDiagonal(Polygon& polygon, Line diagonal){
  // auto holes = bg::interior_rings(polygon);

  // // 1. Read the diagonal and the vertices of partition
  // Line res_line = diagonal;
  // Polygon::ring_type res_hole = polygon.outer();

  // while(true){
  //   // 2. While the diagonal is intersected by the holes, do
  //   bool intersects = false;
  //   for(auto& hole : holes){
  //     if(bg::crosses(hole, res_line)){
  //       // std::cout << "crosses: \n";
  //       // std::cout << bg::wkt(hole) << std::endl;
  //       // std::cout << bg::wkt(res_line) << std::endl;
  //       intersects = true;
  //       break;
  //     }
  //   }
  //   if(!intersects){
  //     break;
  //   }
    
  //   // 3. Find all the edges of holes which intersect d, and calculate the
  //   // corresponding intersection points.
  //   std::vector<Point2d> intersections;
  //   std::vector<Line> intersected_lines;
  //   std::vector<Polygon::ring_type> intersected_holes;
  //   for(auto& hole : holes){
  //     // Iterate over edges and find intersections with the diagonal
  //     for(size_t i=0; i<hole.size()-1; ++i){
  //       Line cur_edge{hole[i], hole[i+1]};
  //       std::vector<Point2d> cur_intersections;  // container for the output
  //       bg::intersection(cur_edge, res_line, cur_intersections);
  //       if(cur_intersections.size()){
  //         intersections.insert(intersections.end(), cur_intersections.begin(), cur_intersections.end());
  //         intersected_lines.push_back(cur_edge);
  //         intersected_holes.push_back(hole);
  //       }
  //     }
  //   }

  //   // 4. Find the intersection point closest to diagonal[0], and endpoint
  //   // of intersected edge closest to diagonal[0]
  //   Point2d endpoint;
  //   size_t hole_index = 0;
  //   float min = std::numeric_limits<float>::max();
  //   for(size_t i=0; i<intersections.size(); ++i){
  //     float tmp = bg::distance(res_line[0], intersections[i]);
  //     if(tmp > min){
  //       continue;
  //     }
  //     min = tmp;
  //     hole_index = i;
  //     float d1 = bg::distance(res_line[0], intersected_lines[i][0]);
  //     float d2 = bg::distance(res_line[0], intersected_lines[i][1]);
  //     if(d1 < d2){
  //       endpoint = intersected_lines[i][0];
  //     }else{
  //       endpoint = intersected_lines[i][1];
  //     }
  //   }

  //   // 5. Update diagonal and corresponding hole
  //   res_line[1] = endpoint;
  //   res_hole = intersected_holes[hole_index];
  // }

  // return std::pair<Polygon::ring_type, Line>(res_hole, res_line);

  Polygon::ring_type res_hole;
  Line res_line;
  return std::pair<Polygon::ring_type, Line>(res_hole, res_line);
}

float DiagonalDecomposition::ang(Point2d a, Point2d b, Point2d c) {
  bg::subtract_point(a, b);
  bg::subtract_point(c, b);
  Point2d zero{0, 0};

  float cos_a = bg::get<0>(a) / bg::distance(a, zero);
  float cos_c = bg::get<0>(c) / bg::distance(c, zero);

  // std::cout << "cos_a: " << cos_a << std::endl;
  // std::cout << "cos_c: " << cos_c << std::endl;

  float a1 = std::acos(cos_a);
  if(bg::get<1>(a) < 0){
    a1 = 2 * M_PI - a1;
  }

  float c1 = std::acos(cos_c);
  if(bg::get<1>(c) < 0){
    c1 = 2 * M_PI - c1;
  }

  // std::cout << "a1: " << a1 << std::endl;
  // std::cout << "c1: " << c1 << std::endl;

  return fmod(2 * M_PI - a1 + c1, 2*M_PI);
}

// void DiagonalDecomposition::getPolygonBoundaries(Polygon& polyg, float& max_x, float& min_x,
//                                                     float& max_y, float& min_y){
//   // Initialize values
//   max_x = std::numeric_limits<float>::lowest();
//   min_x = std::numeric_limits<float>::max();
//   max_y = std::numeric_limits<float>::lowest();
//   min_y = std::numeric_limits<float>::max();
//   auto outer_ring = current_polygon_.outer();

//   for(size_t i=0; i<outer_ring.size(); ++i){
//     // Get position in original axes
//     float tmp_x = bg::get<0>(outer_ring[i]);
//     float tmp_y = bg::get<1>(outer_ring[i]);

//     // Update extrems
//     max_x = max_x < tmp_x ? tmp_x : max_x;
//     min_x = min_x > tmp_x ? tmp_x : min_x;

//     max_y = max_y < tmp_y ? tmp_y : max_y;
//     min_y = min_y > tmp_y ? tmp_y : min_y;
//   }
// }

void DiagonalDecomposition::start() {
  std::cout << "start\n";
}

void DiagonalDecomposition::setStart(Ogre::Vector3 position){
  std::cout << "setStart\n";
}

void DiagonalDecomposition::setPolygon(std::string frame_id, Polygon &new_polygon, bool update){
  std::cout << "setPolygon\n";
}

void DiagonalDecomposition::setAngle(int angle, bool update){
  std::cout << "setAngle\n";
}

void DiagonalDecomposition::setOverlap(float percentage, bool update){
  std::cout << "setOverlap\n";
}

void DiagonalDecomposition::setHeight(float height, bool update){
  std::cout << "setHeight\n";
}

void DiagonalDecomposition::setFrame(std::string new_frame, bool update){
  std::cout << "setFrame\n";
}

} // namespace mrs_rviz_plugins

#include <pluginlib/class_list_macros.hpp>
PLUGINLIB_EXPORT_CLASS(mrs_rviz_plugins::DiagonalDecomposition, mrs_rviz_plugins::CoverageMethod)