#include <coverage_path_planning/diagonal_decomposition.h>

#include <boost/geometry.hpp>

#include <vector>
#include <limits>
#include <cmath>

namespace bg = boost::geometry;

using Polygon = mrs_lib::Polygon;
using Point2d = mrs_lib::Point2d;

namespace mrs_rviz_plugins {

void DiagonalDecomposition::initialize (rviz::Property* property_container, Ogre::SceneManager* scene_manager, Ogre::SceneNode* root_node){

}

void DiagonalDecomposition::compute() {
  std::cout << "compute\n";
  
  // outer
  Polygon poly = mrs_lib::Polygon();
  {mrs_lib::Point2d p{2, 12};
    bg::append(poly, p);}

  {mrs_lib::Point2d p{17, 12};
    bg::append(poly, p);}
  
  {mrs_lib::Point2d p{20, 10};
    bg::append(poly, p);}

  {mrs_lib::Point2d p{20, 0};
    bg::append(poly, p);}

  {mrs_lib::Point2d p{15, 10};
    bg::append(poly, p);}
  
  {mrs_lib::Point2d p{1.75, 0};
    bg::append(poly, p);}
  
  {mrs_lib::Point2d p{0, 10};
    bg::append(poly, p);}

  {mrs_lib::Point2d p{2, 12};
    bg::append(poly, p);}

  // bg::correct(poly);
  std::string msg;
  bg::is_valid(poly, msg);
  std::cout << msg << std::endl;

    getPartition(poly, 0);
  for(int i=0; i<7; i++){
    // std::cout << "got a partition\n";
  }
}

std::pair<mrs_lib::Polygon, DiagonalDecomposition::Line> DiagonalDecomposition::getPartition(Polygon& border, int index_start) {
  // Todo: implement me
  Polygon::ring_type outer = border.outer();

  // the first and last points of ring must be equal, 
  // the following is done for prettier computations
  if(index_start == outer.size()-1){
    index_start = 0; 
  }
  // This is for iterating in counter-clockwise direction
  // std::vector<size_t> indices(outer.size()-1);
  // for(size_t i=0; i<indices.size(); ++i){
  //   int cur = index_start - i;
  //   indices[i] = cur < 0 ? indices.size() + cur : cur;
  // }

  std::vector<size_t> indices(outer.size()-1);
  for(size_t i=0; i<indices.size(); ++i){
    int cur = index_start + i;
    indices[i] = cur % indices.size();
  }
  std::cout << std::endl;

  // |---------------- MP3 algorithm ----------------|

  // Initially, the list consists of one vertex.
  Polygon cur_part;
  bg::append(cur_part, outer[indices[0]]);

  // Then we add the next consecutive vertex (in clockwise order) of P
  // Note: the points in Polygon are stored in counter-clockwise order
  bg::append(cur_part, outer[indices[1]]);
  bool is_outer_convex = true;

  // We go on adding new vertices to L until all the vertices of P are in L...
  for(int i=1; i<indices.size()-1; i++){
    // ... or until we first find a vertex failing one of the three conditions.
    // Note: indices[i] is the index of last vertex in cur_part and we consider adding indices[i+1]
    
    if(ang(outer[indices[i-1]], outer[indices[i]], outer[indices[i+1]]) > M_PI ||
      ang(outer[indices[i]], outer[indices[i+1]], outer[indices[0]]) > M_PI    ||
      ang(outer[indices[i+1]], outer[indices[0]], outer[indices[1]]) > M_PI)
    {
      is_outer_convex = false;
      break;
    }
    bg::append(cur_part, outer[indices[i+1]]);
  }

  // If the convex polygon generated is the whole polygon P, the algorithm stops
  if(is_outer_convex){
    Line res_line = {outer[index_start], outer[index_start]};
    std::cout << "terminating\n";
    std::cout << bg::wkt(cur_part) << std::endl;
    return std::pair<Polygon, Line>(cur_part, res_line);
  }

  // If k > 2, then we have to check whether the convex polygon
  // generated by the diagonal v_k v_1 contains vertices of P \ L.
  if(cur_part.outer().size() > 2){
    Polygon tmp_complete = cur_part;
    bg::append(tmp_complete, cur_part.outer()[0]);
    bg::correct(tmp_complete);

    std::cout << std::endl << std::endl;
    for(int i=cur_part.outer().size(); i<indices.size(); i++){ // iterating over vertices of P \ L.
      // If a vertex v is found to be in the polygon generated by L, then 
      // we remove from L its last vertex v_k and all the vertices of L in 
      // the half-plane generated by [v_1, v] containing v_k .
      if(bg::within(outer[indices[i]], tmp_complete)){
        Point2d v_1 = cur_part.outer().front();
        Point2d v_k = cur_part.outer().back();
        Point2d v = outer[indices[i]];

        float a = (bg::get<1>(v) - bg::get<1>(v_1)) / (bg::get<0>(v) - bg::get<0>(v_1));
        float b = -1;
        float c = bg::get<1>(v_1) - (a * bg::get<0>(v_1));

        // Note: we only consider sign of distance, so the denominator is not needed
        // float abs_w = std::sqrt(std::pow(a, 2) + std::pow(b, 2));
        float dist_v_k = (a * bg::get<0>(v_k)) + (b * bg::get<1>(v_k)) + c ; //  / abs_w;

        // Starting from 1 in order not to delete the first vertex because of inaccuracy
        for(int j=1; j<cur_part.outer().size();){
          float cur_dist =  (a * bg::get<0>(cur_part.outer()[j])) + (b * bg::get<1>(cur_part.outer()[j])) + c;
          if((cur_dist > 0 && dist_v_k > 0) || (cur_dist < 0 && dist_v_k < 0)){
            cur_part.outer().erase(cur_part.outer().begin() + j);
          }else{
            ++j;
          }
        }
      }
    }

  }

  std::cout << bg::wkt(cur_part) << std::endl;





  Polygon res1;
  Line res2;
  return std::pair<Polygon, Line>(res1, res2);
}

// Algorithm 2: Procedure DrawTrueDiagonal
std::pair<mrs_lib::Polygon::ring_type, DiagonalDecomposition::Line> DiagonalDecomposition::drawTrueDiagonal(Polygon& polygon, Line diagonal){
  auto holes = bg::interior_rings(polygon);

  // 1. Read the diagonal and the vertices of partition
  Line res_line = diagonal;
  Polygon::ring_type res_hole = polygon.outer();

  while(true){
    // 2. While the diagonal is intersected by the holes, do
    bool intersects = false;
    for(auto& hole : holes){
      if(bg::crosses(hole, res_line)){
        // std::cout << "crosses: \n";
        // std::cout << bg::wkt(hole) << std::endl;
        // std::cout << bg::wkt(res_line) << std::endl;
        intersects = true;
        break;
      }
    }
    if(!intersects){
      break;
    }
    
    // 3. Find all the edges of holes which intersect d, and calculate the
    // corresponding intersection points.
    std::vector<Point2d> intersections;
    std::vector<Line> intersected_lines;
    std::vector<Polygon::ring_type> intersected_holes;
    for(auto& hole : holes){
      // Iterate over edges and find intersections with the diagonal
      for(size_t i=0; i<hole.size()-1; ++i){
        Line cur_edge{hole[i], hole[i+1]};
        std::vector<Point2d> cur_intersections;  // container for the output
        bg::intersection(cur_edge, res_line, cur_intersections);
        if(cur_intersections.size()){
          intersections.insert(intersections.end(), cur_intersections.begin(), cur_intersections.end());
          intersected_lines.push_back(cur_edge);
          intersected_holes.push_back(hole);
        }
      }
    }

    // 4. Find the intersection point closest to diagonal[0], and endpoint
    // of intersected edge closest to diagonal[0]
    Point2d endpoint;
    size_t hole_index = 0;
    float min = std::numeric_limits<float>::max();
    for(size_t i=0; i<intersections.size(); ++i){
      float tmp = bg::distance(res_line[0], intersections[i]);
      if(tmp > min){
        continue;
      }
      min = tmp;
      hole_index = i;
      float d1 = bg::distance(res_line[0], intersected_lines[i][0]);
      float d2 = bg::distance(res_line[0], intersected_lines[i][1]);
      if(d1 < d2){
        endpoint = intersected_lines[i][0];
      }else{
        endpoint = intersected_lines[i][1];
      }
    }

    // 5. Update diagonal and corresponding hole
    res_line[1] = endpoint;
    res_hole = intersected_holes[hole_index];
  }

  return std::pair<Polygon::ring_type, Line>(res_hole, res_line);
}

float DiagonalDecomposition::ang(Point2d a, Point2d b, Point2d c) {
  bg::subtract_point(a, b);
  bg::subtract_point(c, b);
  Point2d zero{0, 0};

  float cos_a = bg::get<0>(a) / bg::distance(a, zero);
  float cos_c = bg::get<0>(c) / bg::distance(c, zero);

  // std::cout << "cos_a: " << cos_a << std::endl;
  // std::cout << "cos_c: " << cos_c << std::endl;

  float a1 = std::acos(cos_a);
  if(bg::get<1>(a) < 0){
    a1 = 2 * M_PI - a1;
  }

  float c1 = std::acos(cos_c);
  if(bg::get<1>(c) < 0){
    c1 = 2 * M_PI - c1;
  }

  // std::cout << "a1: " << a1 << std::endl;
  // std::cout << "c1: " << c1 << std::endl;

  return fmod(2 * M_PI - a1 + c1, 2*M_PI);
}

// void DiagonalDecomposition::getPolygonBoundaries(Polygon& polyg, float& max_x, float& min_x,
//                                                     float& max_y, float& min_y){
//   // Initialize values
//   max_x = std::numeric_limits<float>::lowest();
//   min_x = std::numeric_limits<float>::max();
//   max_y = std::numeric_limits<float>::lowest();
//   min_y = std::numeric_limits<float>::max();
//   auto outer_ring = current_polygon_.outer();

//   for(size_t i=0; i<outer_ring.size(); ++i){
//     // Get position in original axes
//     float tmp_x = bg::get<0>(outer_ring[i]);
//     float tmp_y = bg::get<1>(outer_ring[i]);

//     // Update extrems
//     max_x = max_x < tmp_x ? tmp_x : max_x;
//     min_x = min_x > tmp_x ? tmp_x : min_x;

//     max_y = max_y < tmp_y ? tmp_y : max_y;
//     min_y = min_y > tmp_y ? tmp_y : min_y;
//   }
// }

void DiagonalDecomposition::start() {
  std::cout << "start\n";
}

void DiagonalDecomposition::setStart(Ogre::Vector3 position){
  std::cout << "setStart\n";
}

void DiagonalDecomposition::setPolygon(std::string frame_id, Polygon &new_polygon, bool update){
  std::cout << "setPolygon\n";
}

void DiagonalDecomposition::setAngle(int angle, bool update){
  std::cout << "setAngle\n";
}

void DiagonalDecomposition::setOverlap(float percentage, bool update){
  std::cout << "setOverlap\n";
}

void DiagonalDecomposition::setHeight(float height, bool update){
  std::cout << "setHeight\n";
}

void DiagonalDecomposition::setFrame(std::string new_frame, bool update){
  std::cout << "setFrame\n";
}

} // namespace mrs_rviz_plugins

#include <pluginlib/class_list_macros.hpp>
PLUGINLIB_EXPORT_CLASS(mrs_rviz_plugins::DiagonalDecomposition, mrs_rviz_plugins::CoverageMethod)